
* CANCELLED ASIO 的研究
  CLOSED: [2023-06-03 Sat 20:00]
  - State "CANCELLED"  from "STARTED"    [2023-06-03 Sat 20:00] \\
    我怕是看不玩啊, 那么多模板
  :LOGBOOK:
  CLOCK: [2023-06-03 Sat 19:01]--[2023-06-03 Sat 19:40] =>  0:39
  - [X] asio 的线程模型
    - [X] io_service 
      - [X] 线程安全
        - [X] 单线程是安全的
        - [X] 多线程情况 : 同一个对象的不同方法, 如果没有被 io_service 分发到不同的线程同时执行, 则是安全的
      - [X] 使用方法
        - [X] Post
        - [X] 把 Sockte 构造, 然后 RUN 
    - [X] one io_servcie per thread - 某个线程不能阻塞
    - [X] one io_service multhread - 线程安全问题
  CLOCK: [2023-06-03 Sat 16:27]--[2023-06-03 Sat 16:47] =>  0:20
  - [ ] Asio 的历史
  :END:


* STARTED [#A] Libevent 
  :LOGBOOK:
  CLOCK: [2023-06-04 Sun 20:44]--[2023-06-04 Sun 21:12] =>  0:28
  - [ ] Event_base 
  CLOCK: [2023-06-04 Sun 20:24]--[2023-06-04 Sun 20:44] =>  0:20
  - [ ] Epoll 与 Reactor2 
  CLOCK: [2023-06-04 Sun 19:10]--[2023-06-04 Sun 20:11] =>  1:01
  - [ ] Epoll 与 Reactor 
  :END:

- [ ] 目标
  - [ ] 编写 Epoll 服务器和客户端
  - [ ] 使用 Reactor 结构改造上面的程序

  

* STARTED [#A] <<操作系统导论>>
  - [ ] 基于锁的并发数据结构
  - [ ] 条件变量详解
  - [ ] 信号量
  - [ ] 常见的并发问题
  - [ ] 基于事件的并发
  :LOGBOOK:
  CLOCK: [2023-06-05 Mon 11:54]--[2023-06-05 Mon 13:03] =>  1:09
  - [X] [100%] 锁详解 1: 自旋锁的原理
    - [X] 不借助硬件实现自旋锁
      - [X] 安全性 - 锁本身也会发生竞争条件
      - [X] 性能   - 一个线程没有获取锁, 将会一直 While 旋转, 当单个 CPU 时, 只能等待上下文切换
    - [X] 借助 原子交换 (test-and-set 指令实现自旋锁)
    - [X] 自旋锁的优势与劣势
      - [X] 单 CPU 时候很浪费, 因为多个线程都变成在自旋, 上下文切换也没用
      - [X] 多 CPU 时, 因为任务完成的快, 反而另一个 CPU 的线程只需等待一会避免了线程切换.
  CLOCK: [2023-06-05 Mon 10:26]--[2023-06-05 Mon 10:59] =>  0:33
  - [X] [100%] 线程的最基本 API 
    - [X] pthread_create / pthread_join
    - [X] pthread_mutex_ / pthread_mytex_try

      互斥锁是不得到锁就会一直阻塞, trylock 是会直接失败返回
    - [X] pthread_cond_wait / pthread_cond_signal()

      线程的协作, 两个的 API 的前置条件都是要拿到锁. Wait 放弃锁进入睡眠, 等到条件成熟, 由另外的线程唤醒他并让他重新得到锁. 
  CLOCK: [2023-06-05 Mon 09:33]--[2023-06-05 Mon 10:22] =>  0:49
  - [X] [100%] 线程的并发问题
    - [X] 线程并发访问的竞争问题
      - [X] 如何诞生 - 访问数据是由多条指令完成, 如果处于中间状态被中断然后切换至其他线程, 那么其他线程看到的是中间数据.
      - [X] 提到了解决问题的方向是原子操作, 就是硬件或操作系统保证线程访问数据是没有或一次完成, 没有中间状态. 
      - [X] 提出临界区的概念, 只有单个线程能进入的代码片段, 叫做临界区, 保证了只有一个线程访问数据, 不会被中断, 没有中间状态.
    - [X] 提到线程除了并发访问的另一个用途, 唤醒与交互
  CLOCK: [2023-06-04 Sun 21:36]--[2023-06-04 Sun 22:26] =>  0:50
  - [X] 进程的虚拟化复习
  :END:

  
* STARTED [#A] C++ 
  :LOGBOOK:
  CLOCK: [2023-06-06 Tue 15:23]--[2023-06-06 Tue 16:35] =>  1:12
  CLOCK: [2023-06-06 Tue 14:07]--[2023-06-06 Tue 14:30] =>  0:23
  CLOCK: [2023-06-06 Tue 13:00]--[2023-06-06 Tue 13:59] =>  0:59
  CLOCK: [2023-06-06 Tue 09:16]--[2023-06-06 Tue 10:10] =>  0:54
  CLOCK: [2023-06-06 Tue 07:59]--[2023-06-06 Tue 08:56] =>  0:57
  CLOCK: [2023-06-05 Mon 23:15]--[2023-06-06 Tue 00:20] =>  1:05
  CLOCK: [2023-06-05 Mon 19:16]--[2023-06-05 Mon 20:21] =>  1:05
  - [-] [66%] 通过 <<C++ 新经典复习当年的知识>>
    - [X] STL 
      - [X] 容器
      - [X] 迭器
      - [X] 算法
      - [X] 函数对象(又名仿函数) : 用于算法, 可以用内置和自己实现函数对象, 好处就是把函数像对象一样保持
      - [X] 适配器
        - [X] STL 适配器   : Stack
        - [X] 迭代器适配器 : reverse_iter
        - [X] 函数适配器   : bind, 我理解是生成新的函数对象, 
    - [X] 线程
      - [X] 锁
      - [X] 条件变量
      - [X] 任务 task
      - [X] 線程傳遞套餐 promise發送/future接受 
      - [X] 原子操作 - 講的非常差
    - [ ] 智能指针
  CLOCK: [2023-06-05 Mon 18:40]--[2023-06-05 Mon 19:16] =>  0:36
  - [X] 确定学习目标
  :END:

- [-] 通过 <<C++ 新经典复习当年的知识>>
  - [X] STL 
  - [ ] 智能指针
  - [ ] 线程
- [ ] 通过 <<C++ 新特性>> 与 C 比较进行进阶
- [ ] C++ 并发学习并发编程
- [ ] 用 C++ 重写 Libevent-linux 版本, 1000 行搞定 


  
* <<计算机网络>>



* <<数据结构>>